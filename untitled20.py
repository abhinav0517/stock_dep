# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sGlO3W7v7lvPSov_sjB66Y6mPFIMv29g
"""

# Import Libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import warnings
from pmdarima import auto_arima  # For automatic (p,d,q) selection

warnings.filterwarnings('ignore')

# Load Dataset
file_path = "/content/AAPL.csv"  # Update path if needed
df = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')

# Ensure Data is Sorted by Date
df = df.sort_index()

# Select 'Close' price for analysis
df = df[['Close']]
df.dropna(inplace=True)

# Set frequency to business days (B)
df = df.asfreq('B')
df.fillna(method='ffill', inplace=True)  # Fill missing values

# 📌 Plot Closing Price Trend
plt.figure(figsize=(12, 6))
plt.plot(df['Close'], label="Apple Stock Close Price", color="blue")
plt.title("Apple Stock Price (2012-2019)")
plt.xlabel("Year")
plt.ylabel("Close Price")
plt.legend()
plt.show()

# 📌 ADF Test Function
def adf_test(series):
    result = adfuller(series)
    print(f'ADF Statistic: {result[0]:.5f}')
    print(f'p-value: {result[1]:.5f}')
    if result[1] < 0.05:
        print("The series is stationary.")
    else:
        print("The series is NOT stationary. Differencing is needed.")

# Check Stationarity
print("\n📌 Checking Stationarity Before Differencing:")
adf_test(df['Close'])

# First Differencing if Required
df_diff = df.diff().dropna()

print("\n📌 Checking Stationarity After Differencing:")
adf_test(df_diff['Close'])

# 📌 Plot ACF and PACF
plt.figure(figsize=(12, 6))
plot_acf(df_diff['Close'], lags=40)  # ACF Plot
plt.show()

plt.figure(figsize=(12, 6))
plot_pacf(df_diff['Close'], lags=40)  # PACF Plot
plt.show()

# 📌 Auto-ARIMA to Find Best (p,d,q)
print("\n📌 Running Auto-ARIMA to find best (p,d,q)...")
auto_arima_model = auto_arima(df['Close'], seasonal=False, stepwise=True, trace=True)
best_p, best_d, best_q = auto_arima_model.order
print(f"\n✅ Best ARIMA Order: ({best_p}, {best_d}, {best_q})")

# 📌 Train-Test Split (80% Train, 20% Test)
split_idx = int(len(df) * 0.8)
train, test = df.iloc[:split_idx], df.iloc[split_idx:]

# 📌 Train ARIMA Model
print("\n📌 Training ARIMA Model...")
arima_model = ARIMA(train['Close'], order=(best_p, best_d, best_q))
arima_fit = arima_model.fit()

# 📌 Forecast Test Data
arima_forecast = arima_fit.forecast(steps=len(test))

# 📌 Evaluate Model Performance
mae = mean_absolute_error(test['Close'], arima_forecast)
rmse = np.sqrt(mean_squared_error(test['Close'], arima_forecast))
r2 = r2_score(test['Close'], arima_forecast)

print("\n📌 ARIMA Model Evaluation:")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R² Score: {r2:.4f}")

# 📌 Plot Predictions vs Actual Stock Prices
plt.figure(figsize=(12, 6))
plt.plot(train['Close'], label="Training Data", color="blue")
plt.plot(test['Close'], label="Actual Test Data", color="green")
plt.plot(test.index, arima_forecast, label="ARIMA Prediction", color="red", linestyle="dashed")
plt.title("ARIMA Model - Apple Stock Price Prediction")
plt.xlabel("Year")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# 📌 Predict Next 30 Days
future_dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=30, freq='B')
future_forecast = arima_fit.forecast(steps=30)

# 📌 Save Predictions to DataFrame
future_predictions = pd.DataFrame({"Date": future_dates, "Predicted Close": future_forecast})
future_predictions.set_index("Date", inplace=True)

# 📌 Plot Future Predictions
plt.figure(figsize=(12, 6))
plt.plot(df['Close'], label="Historical Data", color="blue")
plt.plot(future_predictions, label="30-Day Forecast", color="red", linestyle="dashed")
plt.title("Apple Stock Price Prediction (Next 30 Days)")
plt.xlabel("Date")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# 📌 Print Next 30 Days Predictions
print("\n📌 Predicted Stock Prices for Next 30 Days:")
print(future_predictions.head(30))

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

warnings.filterwarnings("ignore")

# Load Dataset
file_path = "/content/AAPL.csv"  # Change if needed
df = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')

# Select only 'Close' price for prediction
df = df[['Close']]
df.dropna(inplace=True)

# Plot Closing Price Trend
plt.figure(figsize=(12, 6))
plt.plot(df, label="Apple Stock Close Price", color="blue")
plt.title("Apple Stock Price (2012-2019)")
plt.xlabel("Year")
plt.ylabel("Close Price")
plt.legend()
plt.show()

# ADF Test to Check Stationarity
def adf_test(series):
    result = adfuller(series)
    print(f"\nADF Statistic: {result[0]}")
    print(f"p-value: {result[1]}")
    if result[1] < 0.05:
        print("The series is Stationary.")
    else:
        print("The series is NOT Stationary. Differencing is needed.")

# Apply ADF Test
print("\nChecking Stationarity of 'Close' Prices:")
adf_test(df['Close'])

# Differencing if Non-Stationary
df_diff = df.diff().dropna()
print("\nChecking Stationarity after Differencing:")
adf_test(df_diff['Close'])

# Splitting Data into Train and Test Sets
train = df[df.index < "2019-01-01"]
test = df[df.index >= "2019-01-01"]

# Train SARIMA Model
sarima_model = SARIMAX(train['Close'], order=(5, 1, 0), seasonal_order=(2, 1, 0, 12))
sarima_fit = sarima_model.fit()

# Forecast Test Data using SARIMA
sarima_forecast = sarima_fit.forecast(steps=len(test))

# Calculate Evaluation Metrics
sarima_mae = mean_absolute_error(test['Close'], sarima_forecast)
sarima_rmse = np.sqrt(mean_squared_error(test['Close'], sarima_forecast))
sarima_r2 = r2_score(test['Close'], sarima_forecast)

print("\n📌 SARIMA Model Evaluation:")
print(f"Mean Absolute Error (MAE): {sarima_mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {sarima_rmse:.2f}")
print(f"R² Score: {sarima_r2:.4f}")

# Plot SARIMA Predictions vs Actual Stock Prices
plt.figure(figsize=(12, 6))
plt.plot(train['Close'], label="Training Data", color="blue")
plt.plot(test['Close'], label="Actual Test Data (2019)", color="red")
plt.plot(test.index, sarima_forecast, label="SARIMA Prediction", color="purple")
plt.title("SARIMA Model - Apple Stock Price Prediction")
plt.xlabel("Year")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# -------------------------------
#  Predict Next 30 Days
# -------------------------------
import datetime

# Generate future dates
future_dates = [df.index[-1] + datetime.timedelta(days=i) for i in range(1, 31)]

# Predict the next 30 days
future_forecast = sarima_fit.forecast(steps=30)

# Store in DataFrame
future_predictions = pd.DataFrame({"Date": future_dates, "Predicted Close": future_forecast})
future_predictions.set_index("Date", inplace=True)

# Plot Future Predictions
plt.figure(figsize=(12, 6))
plt.plot(df['Close'], label="Historical Data", color="blue")
plt.plot(future_predictions, label="30-Day Forecast", color="red")
plt.title("Apple Stock Price Prediction (Next 30 Days)")
plt.xlabel("Year")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# Print the first few predictions
print("\n📅 SARIMA Model - Predicted Next 30 Days Stock Prices:")
print(future_predictions.head(30))

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from xgboost import XGBRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Load Dataset
file_path = "/content/AAPL.csv"  # Update path if needed
df = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')

# Use only 'Close' price for prediction
df = df[['Close']]
df.dropna(inplace=True)

# -------------------------------
#  Feature Engineering (Lag Features)
# -------------------------------
def create_lagged_features(df, lag=5):
    X, y = [], []
    if len(df) <= lag:
        raise ValueError("Data length must be greater than lag value.")

    for i in range(lag, len(df)):
        X.append(df['Close'].iloc[i-lag:i].values)  # Last 'lag' days of closing prices
        y.append(df['Close'].iloc[i])  # The current day's closing price
    return np.array(X), np.array(y)

# Set lag value
lag = 5
X, y = create_lagged_features(df, lag)

# -------------------------------
#  Train-Test Split (No Shuffling)
# -------------------------------
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# -------------------------------
#  Train XGBoost Model
# -------------------------------
xgb_model = XGBRegressor(objective='reg:squarederror', n_estimators=1000, learning_rate=0.01)
xgb_model.fit(X_train, y_train)

# -------------------------------
#  Make Predictions & Evaluate
# -------------------------------
y_pred = xgb_model.predict(X_test)

# Evaluation Metrics
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

# Print Evaluation Results
print("📌 XGBoost Model Evaluation:")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"R² Score: {r2:.4f}")

# Plot the predictions vs actual values
plt.figure(figsize=(12, 6))
plt.plot(range(len(y_test)), y_test, label="Actual", color="green")
plt.plot(range(len(y_test)), y_pred, label="Predicted", color="red", linestyle='dashed')
plt.title("XGBoost Stock Price Prediction")
plt.xlabel("Test Data Points")
plt.ylabel("Closing Price")
plt.legend()
plt.show()

# -------------------------------
#  Predict Next 30 Days
# -------------------------------
# Get the last 'lag' days from the dataset
last_lag_values = list(df['Close'].iloc[-lag:].values)
future_predictions = []

for i in range(30):
    input_data = np.array(last_lag_values[-lag:]).reshape(1, -1)  # Convert to 2D array for XGBoost
    next_pred = xgb_model.predict(input_data)[0]  # Predict next day's closing price
    future_predictions.append(next_pred)
    last_lag_values.append(next_pred)  # Append for future predictions

# Create date range for the next 30 days
future_dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=30)

# Create DataFrame for Future Predictions
future_df = pd.DataFrame({"Date": future_dates, "Predicted Close": future_predictions})
future_df.set_index("Date", inplace=True)

# -------------------------------
#  Plot Future Predictions
# -------------------------------
plt.figure(figsize=(12, 6))
plt.plot(df.index, df['Close'], label="Historical Data", color="blue")
plt.plot(future_df.index, future_df["Predicted Close"], label="30-Day Forecast", color="red", linestyle='dashed')
plt.title("Apple Stock Price Prediction (Next 30 Days)")
plt.xlabel("Date")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# Print Future Predictions
print(future_df.head(30))

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.statespace.sarimax import SARIMAX
from pmdarima import auto_arima  # Auto-ARIMA for best p, d, q selection
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Load Dataset
file_path = "/content/AAPL.csv"  # Update path if needed
df = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')

# Use only 'Close' price for prediction
df = df[['Close']]
df.dropna(inplace=True)

# -------------------------------
#  Check Stationarity & Differencing
# -------------------------------
from statsmodels.tsa.stattools import adfuller

def check_stationarity(series):
    result = adfuller(series)
    print(f"ADF Statistic: {result[0]}")
    print(f"p-value: {result[1]}")
    if result[1] < 0.05:
        print("✅ The series is stationary (No differencing needed).")
    else:
        print("❌ The series is NOT stationary (Differencing needed).")

# Check original series
print("\n📌 Checking Stationarity for Original Data:")
check_stationarity(df['Close'])

# Apply Differencing if needed
df_diff = df.diff().dropna()
print("\n📌 Checking Stationarity for Differenced Data:")
check_stationarity(df_diff['Close'])

# -------------------------------
#  Auto-ARIMA for Best (p, d, q)
# -------------------------------
print("\n🔍 Finding Best ARIMA Order...")
auto_arima_model = auto_arima(df['Close'], seasonal=True, m=12, stepwise=True, trace=True, suppress_warnings=True)
best_p, best_d, best_q = auto_arima_model.order
best_P, best_D, best_Q, best_s = auto_arima_model.seasonal_order

print(f"\n✅ Best SARIMA Order: ({best_p}, {best_d}, {best_q}) x ({best_P}, {best_D}, {best_Q}, {best_s})")

# -------------------------------
#  Train-Test Split
# -------------------------------
train = df[df.index < "2019-01-01"]
test = df[df.index >= "2019-01-01"]

# -------------------------------
#  Train SARIMA Model (Optimized)
# -------------------------------
print("\n🚀 Training Optimized SARIMA Model...")
sarima_model = SARIMAX(train['Close'], order=(best_p, best_d, best_q),
                       seasonal_order=(best_P, best_D, best_Q, best_s),
                       enforce_stationarity=False, enforce_invertibility=False)
sarima_fit = sarima_model.fit()

# -------------------------------
#  Forecast & Evaluate
# -------------------------------
sarima_forecast = sarima_fit.forecast(steps=len(test))

# Calculate Evaluation Metrics
sarima_mae = mean_absolute_error(test['Close'], sarima_forecast)
sarima_rmse = np.sqrt(mean_squared_error(test['Close'], sarima_forecast))
sarima_r2 = r2_score(test['Close'], sarima_forecast)

# Print Results
print("\n📌 Optimized SARIMA Model Evaluation:")
print(f"Mean Absolute Error (MAE): {sarima_mae:.2f}")
print(f"Root Mean Squared Error (RMSE): {sarima_rmse:.2f}")
print(f"R² Score: {sarima_r2:.4f}")

# -------------------------------
#  Plot Predictions vs Actual
# -------------------------------
plt.figure(figsize=(12, 6))
plt.plot(train['Close'], label="Training Data", color="blue")
plt.plot(test['Close'], label="Actual Test Data", color="green")
plt.plot(test.index, sarima_forecast, label="SARIMA Prediction", color="red", linestyle="dashed")
plt.title("Optimized SARIMA Model - Apple Stock Price Prediction")
plt.xlabel("Year")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# -------------------------------
#  Predict Next 30 Days
# -------------------------------
print("\n🔮 Predicting Next 30 Days...")
future_forecast = sarima_fit.forecast(steps=30)
future_dates = pd.date_range(start=df.index[-1] + pd.Timedelta(days=1), periods=30)

# Create DataFrame for Future Predictions
future_df = pd.DataFrame({"Date": future_dates, "Predicted Close": future_forecast})
future_df.set_index("Date", inplace=True)

# -------------------------------
#  Plot Future Predictions
# -------------------------------
plt.figure(figsize=(12, 6))
plt.plot(df['Close'], label="Historical Data", color="blue")
plt.plot(future_df, label="30-Day Forecast", color="red", linestyle='dashed')
plt.title("Optimized SARIMA Model - Apple Stock Price Prediction (Next 30 Days)")
plt.xlabel("Year")
plt.ylabel("Stock Price (USD)")
plt.legend()
plt.grid(True)
plt.show()

# Print Future Predictions
print(future_df.head(30))

